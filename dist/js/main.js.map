{"version":3,"sources":["js/main.js"],"names":["canvas","beginPath","opts","particleAmount","i","moveTo","point1","loop","window","requestAnimationFrame","tick","particles","Particle","length","update","draw","communicatePoints","a","canvasBody","document","getElementById","getContext","w","h","backgroundColor","particleColor","Math","floor","defaultSpeed","communicationRadius","addedRadius","Ypos","this","x","Xpos","random","defaultRadius","radius","addedSpeed","y","speed","directionAngle","color","d","border","arc","PI","closePath","fillStyle","fill","x1","y1","x2","y2","sqrt","pow","points","checkDistance","distance","opacity","lineWidth","strokeStyle","setup","width","innerWidth","height","innerHeight","addEventListener","e","push","pageX","pageY","console","log","preventDefault","menu","menu_bar","menuItems","applyListeners","init","body","querySelector","toggleClass","element","stringClass","classList","contains","remove","add","firstElementChild","querySelectorAll"],"mappings":"YA6EGA,SAAAA,SACAA,IAAAA,GAAAA,GAAOC,EAAAA,EAAPC,KAAAC,eAAAC,IACAJ,UAAOK,KAAOC,GAAAA,UAEdN,QAAAA,sBAAAO,MAGD,QAAAA,QAlFFC,OAAAC,sBAAAF,MA8FIG,OARJV,OAAQI,UAAWF,KAAKC,gBACvBQ,OAAAA,SAAgB,EAAIC,EAAAA,EAAAA,EAGpB,KAAA,GAAAR,GAAA,EAAAA,EAAAO,UAAAE,OAAAT,IAYIO,UAAUP,GAAGU,SAVlBH,UAAAP,GAAeW,MAEXL,KAAAA,GAAAA,GAAAA,EAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAaCM,kBAAkBL,UAAUM,GAAIN,WA7GrC,GAAAO,YAAAC,SAAAC,eAAA,UAGApB,OAASkB,WAAWG,WAAW,MAD/BC,EACAtB,WAASkB,MAAAA,OAAWG,WADpBE,EAGAD,WAAIJ,OAAAV,OAAmBA,YACvBe,KAAIL,EAEJR,MANAc,gBAMU,OAKTC,cAAe,UAHhBtB,eAAAuB,KAAAC,MAAAL,EAAAC,EAAA,KAAA,IACArB,aAAS,EACRsB,WAAAA,GAEArB,cAAAA,EACAyB,YAAAA,EAMAC,oBAAqB,KAFrBC,aAEAD,SAAAA,SAAAA,EAA0BE,GAnB3BC,KAAAC,EAAAC,GAAAR,KAAAS,SAAAb,EAAAU,KAqBArB,EAAAA,GArBAe,KAAAS,SAAAZ,EAuBAX,KAAAA,OAAWV,KAAAkC,cAAeL,KAAfI,SAAoBjC,KAAA4B,YAC9BE,KAAKC,MAAIC,KAAOA,IAAPhC,KAAcwB,cADOM,KACUK,OAAA,GAAAnC,KAAA0B,aAAAF,KAAAS,SAAAjC,KAAAoC,WACxCN,KAAKO,eAAIb,KAAcA,MAAiB,IAAZS,KAALA,UACpBH,KAAKK,MAALnC,KAAcA,cACjB8B,KAAKQ,GACLP,EAAAP,KAAKe,IAAAA,KAAAA,gBAA4Bf,KAAKS,MACtCI,EAAAb,KAAKgB,IAAQxC,KAAKuB,gBAAlBO,KAAAQ,OAECP,KAAGP,OAAS,WACZa,KAAGb,SAFJM,KAAAC,GAAAD,KAAAW,EAAAV,EAIAD,KAAKlB,GAALkB,KAAcW,EAAAJ,GACbP,KAAAY,OAAA,YACAZ,KAAAC,GAAUX,GAAVU,KAAoBC,GAAA,KACpBD,KAAAW,EAAAV,IAAU,IAEXD,KAAKY,GAASrB,GAAAS,KAAAO,GAAU,KAAEP,KAAAW,EAAAJ,IAAA,GACOP,KAAAC,EAAAX,EAAAU,KAAAC,EAAAX,EAAAU,KAAAC,EAC/BD,KAAAO,EAAAhB,EAAYS,KAAZO,EAAAhB,EAAAS,KAAAO,EACAP,KAAAC,EAAA,EAAAD,KAAAC,EAAA,EAAAD,KAAAC,EACDD,KAAGO,EAAKA,EAALP,KAAAO,EAAe,EAAAP,KAAlBO,GAKAP,KAAAjB,KAAA,WACAf,OAAAC,YACAD,OAAA6C,IAAAb,KAAAC,EAAAD,KAAAO,EAAAP,KAAAK,OAAA,EAAA,EAAAX,KAAAoB,IAQA9C,OAAO+C,YACP/C,OAAOgD,UAAYhB,KAAKU,MApBzB1C,OAAAiD,SAiBCjD,cAAOC,SAAPiD,EAAAC,EAAAC,EAAAC,GACArD,MAAAA,MAAWsD,KAAKrB,KAAGsB,IAAnBH,EAA2BF,EAAKb,GAAhCX,KAA2CA,IAAKoB,EAAGK,EAAnD,KAKDnC,kBA9DD,SAAAV,EAAAkD,GAAA,IA+DAC,GAAAA,GAAAA,EAAAA,EAAgBD,EAAA3C,OAAhB4C,IAAAA,CAA0C,GAAAC,GAAAD,cAAAnD,EAAA2B,EAAA3B,EAAAiC,EAAAiB,EAAApD,GAAA6B,EAAAuB,EAAApD,GAAAmC,GACzCoB,EAAYL,EAAK5B,EAAS0B,KAATvB,mBAhElB8B,GAAA,IA0EG3D,OAAO4D,UAAYD,EARtB3D,OAAA6D,YAAA,wBACA7D,OAAAC,YACAD,OAAAK,OAAAC,EAAA2B,EAAA3B,EAAAiC,GACAvB,OAAAA,OAAAA,EAAoBZ,GAAA6B,EAApBjB,EAAAA,GAAAA,GACChB,OAAQI,YACPJ,OAAI0D,WA6BFI,SAGCnD,OAAAA,iBAAA,SAAA,WACAW,EAAAJ,WAAA6C,MAAAvD,OAAAwD,WACDzC,EAAAL,WAAA+C,OAAAzD,OAAA0D,cAIHhD,WAAAiD,iBAAA,QAAA,SAAAC,GAaAzD,UAAU0D,KAAM,GAAIzD,UAASwD,EAAEE,MAAOF,EAAEG,QAXzCC,QAAAC,IAAA9D,UAAAE,UAGAK,WAAAiD,iBAAA,cAAA,SAAAC,GACA5D,EAAAA,iBACCc,UAAIJ,OAAW6C,UAAQvD,OAAOwD,EAAAA,IAW9BI,IAAEM,KAAAA,WACF/D,GAAAA,OAAAA,GAFDgE,MAAAA,GAgBKC,MAAAA,GAXLC,MAAAA,GA0BOC,EAAiB,WAXvBH,EAAMI,iBAAAA,QAAa,WAClBC,EAAgBC,EAAAA,cAChBN,EAAOxD,EAAS8D,kBAiBXC,EAAc,SAACC,EAASC,GAnB9BD,EAAAE,UAAAC,SAAAF,GAaKF,EAAAA,UAAkBK,OAAAH,GASlBD,EAAQE,UAAUG,IAAIJ,KAtBd,WACZJ,EAAO7D,SAAS8D,cAAc,QAC9BN,EAAOxD,SAAS8D,cAAc,cAC9BL,EAAWD,EAAKc,kBAChBjB,QAAQC,IAAI,aAAcG,GAX5BC,EAAa1D,SAAMuE,iBAAA,mBAGlBZ","file":"main.js","sourcesContent":["//var //canvasBody = document.getElementById(\"canvas\"),\n\nvar canvasBody = document.getElementById(\"canvas\"),\ncanvas = canvasBody.getContext(\"2d\"),\n\nw = canvasBody.width = window.innerWidth, //Full width\nh = canvasBody.height = window.innerHeight, //Full height\n\ntick = 0, //Tick in time\n\n//YOU CAN CHANGE OPTIONS HERE. DO NOT REALLY MESS WITH STUFF BELOW THAT\nopts = { //Options, you can change those\n\tbackgroundColor: \"#111\",\n\tparticleColor: \"#fcfcfc\",\n\tparticleAmount: Math.floor((w * h / 650000) * 40), //the initial starting number of points depent on the screen\n\tdefaultSpeed: 1,\n\taddedSpeed: 0.5, //the maximum variation of the speed\n\n\tdefaultRadius: 2,\n\taddedRadius: 2,\n\n\tcommunicationRadius: 150, //The radius for the line\n},\nparticles = [],\n\nParticle = function(Xpos, Ypos){\n\tthis.x = Xpos ? Xpos : Math.random()*w; //If there is not position stated, it takes a random position\n\tthis.y = Ypos ? Ypos : Math.random()*h; //Same here\n    this.radius = opts.defaultRadius + Math.random()*opts.addedRadius; //Radius + a bit of random radius\n\tthis.speed = Math.pow(opts.defaultRadius/this.radius, 6) * opts.defaultSpeed + Math.random()*opts.addedSpeed; //Speed that reversed to thedot size + a bit of random one\n\tthis.directionAngle = Math.floor(Math.random()*360); //The angle of this particle its moving. !!!! TRUE ONLY ON INIT\n\tthis.color = opts.particleColor;\n\tthis.d = { //Object, stores directions. Computes directions according to the random this.directionAngle\n\t\tx: Math.cos(this.directionAngle)*this.speed,\n\t\ty: Math.sin(this.directionAngle)*this.speed\n\t};\n\tthis.update = function(){ //The update function. The function that calculates next coordinates\n\t\tthis.border(); //Checks if this particles touches the border and THEN computes the next coordinates\n\t\tthis.x += this.d.x; //Just adding the direction to the X\n\t\tthis.y += this.d.y; //Same but with Y\n\t};\n\tthis.border = function(){ //The border function. Checks if this thing touches the border\n\t\tif(this.x >= w || this.x <= 0){ //X walls\n\t\t\tthis.d.x *= -1;\n\t\t}\n\t\tif(this.y >= h || this.y <= 0){ //Floor and ceiling\n\t\t\tthis.d.y *= -1;\n\t\t}\n\t\tthis.x > w ? this.x = w : this.x; //This is really important.\n\t\tthis.y > h ? this.y = h : this.y; //Same\n\t\tthis.x < 0 ? this.x = 0 : this.x; //Same\n\t\tthis.y < 0 ? this.y = 0 : this.y; //Same\n\t\t/* line ~49 explanation\n\t\t\tBecause sometimes the speed of the particle can be faster, so it doesn't touch the border - it goes through. And when it goes back it doesn't go all the way inside - it stucks there. So, you have to set the X to the point when it touches. Same with Y\n\t\t*/\n\n\t};\n\tthis.draw = function(){ //Just draws the points. Pretty easy. Takes the coords, color, radius - draws.\n\t\tcanvas.beginPath();\n\t\tcanvas.arc(this.x, this.y, this.radius, 0, Math.PI*2);\n\t\tcanvas.closePath();\n\t\tcanvas.fillStyle = this.color;\n\t\tcanvas.fill();\n\t};\n},\ncheckDistance = function(x1, y1, x2, y2){ //You got it. The point on the graph distance formula.\n\treturn Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n},\n//Here goes the function that makes lines!\n// @param point1 -\tThe point that check for neighboors\n// @param points - \tThe array the point suppose to take thing from\ncommunicatePoints = function(point1, points){\n\tfor(var i = 0; i < points.length; i++){\n\t\tvar distance = checkDistance(point1.x, point1.y, points[i].x, points[i].y);\n\t\tvar opacity = 1 - distance/opts.communicationRadius;\n\t\tif (opacity > 0){ //Draws the line\n\t\t\tcanvas.lineWidth = opacity;\n\t\t\tcanvas.strokeStyle = \"rgba(255,255,255,0.5)\";\n\t\t\tcanvas.beginPath();\n\t\t\tcanvas.moveTo(point1.x, point1.y);\n\t\t\tcanvas.lineTo(points[i].x, points[i].y);\n\t\t\tcanvas.closePath();\n\t\t\tcanvas.stroke();\n\t\t}\n\t}\n};\n\nfunction setup(){ //Function called once to set everything up\nfor(var i = 0; i < opts.particleAmount; i++){\n\tparticles.push( new Particle() );\n}\nwindow.requestAnimationFrame(loop);\n}\n\nfunction loop(){ //Function of loop that will be called for a frame of the animation\n    window.requestAnimationFrame(loop);\n    tick++;\n\n    //Drawing the background. Basically clearing the frame that was before\n    canvas.fillStyle = opts.backgroundColor;\n    canvas.fillRect(0,0,w,h);\n\n    //Executing particle functions\n    for(var i = 0; i < particles.length; i++){\n    \tparticles[i].update();\n    \tparticles[i].draw();\n    }\n    //Executing lines\n    for(var a = 0; a < particles.length/2; a++){\n    \tcommunicatePoints(particles[a], particles);\n    }\n}\n\n//Executing the animation\nsetup();\n\n//Some event listeners for backup to look professional\nwindow.addEventListener(\"resize\", function(){\n\tw = canvasBody.width = window.innerWidth;\n\th = canvasBody.height = window.innerHeight;\n});\n\n//The thing that adds a point. Basically, we pass the coords of the mouse. And they are applied instead of randomness. Check the line 26, 28 to know\ncanvasBody.addEventListener(\"click\", function(e){\n\tparticles.push( new Particle(e.pageX, e.pageY) );\n\tconsole.log(particles.length);\n});\n//The thing that removes a point.\ncanvasBody.addEventListener(\"contextmenu\", function(e){\n\te.preventDefault();\n\tparticles.splice(particles.length - 1, 1); //Takes the last thing from the particles[];\n});\n\n/**\n$(\".menu-toggle\").on('click', function() {\n  $(this).toggleClass(\"on\");\n  $('.menu-section').toggleClass(\"on\");\n  $(\"nav ul\").toggleClass('hidden');\n  $('#wrapper').toggleClass('hidden');\n});\n*/\nconst app = (() => {\n\tlet body;\n\tlet menu;\n\tlet menu_bar;\n\tlet menuItems;\n  let wrapper;\n\n\tconst init = () => {\n\t\tbody = document.querySelector('body');\n\t\tmenu = document.querySelector('.menu-icon');\n\t\tmenu_bar = menu.firstElementChild;\n\t\tconsole.log(\"menu-bar: \", menu_bar);\n\t\tmenuItems = document.querySelectorAll('.nav__list-item');\n    //wrapper = document.querySelector('#wrapper');\n\n\t\tapplyListeners();\n\t}\n\n\tconst applyListeners = () => {\n\t\tmenu.addEventListener('click', () => {\n      toggleClass(body, 'nav-active');\n\t\t\ttoggleClass(menu_bar, 'menu-active');\n      //toggleClass(wrapper, 'hidden')\n    });\n\t}\n\n\tconst toggleClass = (element, stringClass) => {\n    //console.log(\"element: \", element);\n    if (!element.classList.contains(stringClass)) {\n      element.classList.add(stringClass);\n    }\n\t\telse\n\t\t\telement.classList.remove(stringClass);\n\t}\n\n\tinit();\n})();\n"]}